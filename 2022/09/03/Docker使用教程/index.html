

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.png">
  <link rel="icon" href="/img/icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="山上的清风">
  <meta name="keywords" content="">
  
    <meta name="description" content="Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker学习笔记">
<meta property="og:url" content="http://example.com/2022/09/03/Docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="Latiy博客">
<meta property="og:description" content="Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/adorn/docker.png">
<meta property="article:published_time" content="2022-09-03T04:19:03.000Z">
<meta property="article:modified_time" content="2022-11-05T03:08:27.609Z">
<meta property="article:author" content="山上的清风">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/adorn/docker.png">
  
  
  <title>Docker学习笔记 - Latiy博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>山上的清风</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Docker学习笔记">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      山上的清风
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-09-03 12:19" pubdate>
        2022年9月3日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      22k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      183 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Docker学习笔记</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年11月5日 上午
                
              </p>
            
            <div class="markdown-body">
              <h2 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h2><p>​    <a target="_blank" rel="noopener" href="https://hub.docker.com/editions/community/docker-ce-desktop-mac">https://hub.docker.com/editions/community/docker-ce-desktop-mac</a></p>
<h2 id="2、验证"><a href="#2、验证" class="headerlink" title="2、验证"></a>2、验证</h2><h3 id="1-验证Docker是否安装，及其版本"><a href="#1-验证Docker是否安装，及其版本" class="headerlink" title="(1)验证Docker是否安装，及其版本"></a>(1)验证Docker是否安装，及其版本</h3><figure class="highlight applescript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs applescript">$ docker <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure>

<h3 id="2-启动一个-Nginx-容器，检查能正确获取镜像并运行"><a href="#2-启动一个-Nginx-容器，检查能正确获取镜像并运行" class="headerlink" title="(2)启动一个 Nginx 容器，检查能正确获取镜像并运行"></a>(2)启动一个 Nginx 容器，检查能正确获取镜像并运行</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ docker <span class="hljs-built_in">run</span> -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> <span class="hljs-comment">--name webserver nginx</span><br></code></pre></td></tr></table></figure>

<h3 id="3-使用-docker-ps-指令查看运行的容器"><a href="#3-使用-docker-ps-指令查看运行的容器" class="headerlink" title="(3)使用 docker ps 指令查看运行的容器"></a>(3)使用 docker ps 指令查看运行的容器</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xl">$ docker ps<br><br>CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS          PORTS                               NAMES<br><span class="hljs-function"><span class="hljs-title">c191261bc878</span>   nginx     &quot;/docker-entrypoint.…&quot;   3 hours ago   Up 10 seconds   0.0.0.0:80-&gt;</span><span class="hljs-number">80</span>/<span class="hljs-function"><span class="hljs-title">tcp</span>, :::80-&gt;</span><span class="hljs-number">80</span>/tcp   webserver<br></code></pre></td></tr></table></figure>

<h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker run <span class="hljs-literal">-it</span> NAME[:<span class="hljs-type">TAG</span>] 	启动容器<br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> 	查看所有的容器命令<br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">start</span> &lt;容器 ID&gt;		启动容器<br><span class="hljs-variable">$</span> docker stop &lt;容器 ID&gt;		停止容器<br><span class="hljs-variable">$</span> docker restart &lt;容器 ID&gt;   重启容器<br></code></pre></td></tr></table></figure>

<h3 id="4-Nginx-容器已经在-0-0-0-0-80-启动，并映射到-80-端口，打开浏览器访问此地址"><a href="#4-Nginx-容器已经在-0-0-0-0-80-启动，并映射到-80-端口，打开浏览器访问此地址" class="headerlink" title="(4) Nginx 容器已经在 0.0.0.0:80 启动，并映射到 80 端口，打开浏览器访问此地址"></a>(4) Nginx 容器已经在 0.0.0.0:80 启动，并映射到 80 端口，打开浏览器访问此地址</h3><h2 id="3、下载-Kitematic-Mac-zip并解压"><a href="#3、下载-Kitematic-Mac-zip并解压" class="headerlink" title="3、下载 Kitematic-Mac.zip并解压"></a>3、下载 Kitematic-Mac.zip并解压</h2><p>​    Gitee地址：<a target="_blank" rel="noopener" href="https://github.com/docker/kitematic/releases">https://github.com/docker/kitematic/releases</a></p>
<p>​    百度网盘地址：链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1l99Qg2TPLKPUgeXdmNtuxA">https://pan.baidu.com/s/1l99Qg2TPLKPUgeXdmNtuxA</a>  密码: nsqg</p>
<h2 id="4、使用-Kitematic"><a href="#4、使用-Kitematic" class="headerlink" title="4、使用 Kitematic"></a>4、使用 Kitematic</h2><p>​    (1)进入 Docker Hub 登录页面，用户可以选择暂时不登录 ，点击右下角Skip For Now直接进入主页面</p>
<p>​    (2)主页面可见多种常用镜像，点击 CREATE 即可直接创建容器</p>
<p>​    (3)以hello-world-nginx 镜像为例，点击 CREA 后进入下载页面</p>
<p>​    (4)容器运行后，在主页可见运行日志 挂载磁盘（双击可以直接打开）、浏览器预览 以及容器配置（ settings ）等</p>
<p>​    (5)进入配置页面，可见 hostname/port ，以及卷、网络等配置</p>
<p>​    (6)可以在hostname/port更改端口号(以端口号55000为例)</p>
<p>​    (7)用户此时可以打开浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:55000/">http://localhost:55000</a></p>
<h2 id="5、使用Docker镜像"><a href="#5、使用Docker镜像" class="headerlink" title="5、使用Docker镜像"></a>5、使用Docker镜像</h2><h3 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="(1)获取镜像"></a>(1)获取镜像</h3><p>​    命令格式： docker [image] pull NAME [ :TAG] ， NAME 是镜像仓库名称（用来区分镜像）， TAG 是镜像的标签（往往用来表示版本信息）通常情况下， 描述一个镜像需要包括 “名称＋标签“ 信息</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crystal">例如， 获取一个 Ubuntu 系统的基础镜像可以使用如下的命令：<br><span class="hljs-variable">$ </span>docker pull <span class="hljs-symbol">ubuntu:</span><span class="hljs-number">18.04</span><br>注：如果不显式指定TAG, 则默认会选择la迳釭标签，这会下载仓库中最新版本的镜像<br>例：下载一个最新版本的Ubuntu操作系统的镜像，该命令实际上下载的就是 <span class="hljs-symbol">ubuntu:</span>latest镜像<br><span class="hljs-variable">$ </span>docker pull ubuntu<br></code></pre></td></tr></table></figure>

<p>​        注意：一般来说， 镜像的latest 标签意味着该镜像的内容会跟踪最新版本的变更而变化， 内容是不稳定的。因此，从稳定性上考虑，不要在生产环境中忽略镜像的标签信息或使用默认的latest 标记的镜像。</p>
<p>镜像仓库：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">网易镜像中心：http:<span class="hljs-regexp">//</span>hub-mirror.c.<span class="hljs-number">163</span>.com<br>阿里镜像中心：https:<span class="hljs-regexp">//</span>dev.aliyun.com<br>Docker 官方中国区：https:<span class="hljs-regexp">//</span>registry.docker-cn.com<br>ustc： https:<span class="hljs-regexp">//</span>docker.mirrors.ustc.edu.cn<br>daocloud：https:<span class="hljs-regexp">//</span>hub.daocloud.io/<br></code></pre></td></tr></table></figure>

<h3 id="2-查看镜像信息"><a href="#2-查看镜像信息" class="headerlink" title="(2)查看镜像信息"></a>(2)查看镜像信息</h3><h4 id="1-使用images命令列出镜像"><a href="#1-使用images命令列出镜像" class="headerlink" title="1. 使用images命令列出镜像"></a>1. 使用images命令列出镜像</h4><p>列出本地主机上已有镜像的基本信息</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker images<br><span class="hljs-variable">$</span> docker images <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure>

<h4 id="2-使用tag命令添加镜像标签"><a href="#2-使用tag命令添加镜像标签" class="headerlink" title="2. 使用tag命令添加镜像标签"></a>2. 使用tag命令添加镜像标签</h4><p>​    为了方便在后续工作中使用特定镜像，还可以使用 docker tag 命令来为本地镜像任意添加新的标签</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">格式：docker <span class="hljs-keyword">tag</span> <span class="hljs-title">NAME</span>[:<span class="hljs-keyword">TAG</span>] 别名[:<span class="hljs-keyword">TAG</span>]<br>例如，添加 一个新的myubuntu:latest镜像标签：<br>$ docker <span class="hljs-keyword">tag</span> <span class="hljs-title">ubuntu</span>:latest myubuntu:latest<br></code></pre></td></tr></table></figure>

<p>​    注：docker tag命令添加的标签实际上起到了类似链接的作用</p>
<h4 id="3-使用inspect命令查看详细信息"><a href="#3-使用inspect命令查看详细信息" class="headerlink" title="3.使用inspect命令查看详细信息"></a>3.使用inspect命令查看详细信息</h4><p>​    使用 docker [image] inspect 命令可以获取该镜像的详细信息，包括制作者 、适应架构、各层的数字摘要等</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">格式：docker [image] inspect <span class="hljs-symbol">NAME</span>[:<span class="hljs-symbol">TAG</span>]<br>$ docker [image] inspect ubuntu:latest<br>返回的是一个 <span class="hljs-symbol">JSON</span> 格式的消息,如果我们只要其中一项内容时， 可以使用 -f 来指定<br>格式：docker [image] inspect -f &#123;&#123;<span class="hljs-string">&quot;.内容名&quot;</span>&#125;&#125; <span class="hljs-symbol">NAME</span>[:<span class="hljs-symbol">TAG</span>]<br>例：例如， 获取镜像的 <span class="hljs-symbol">Arch</span>让ecture:<br>$ docker [image] inspect -f &#123;&#123;<span class="hljs-string">&quot;.Architecture&quot;</span>&#125;&#125; ubuntu:latest <br></code></pre></td></tr></table></figure>

<h4 id="4-使用-history-命令查看镜像历史"><a href="#4-使用-history-命令查看镜像历史" class="headerlink" title="4. 使用 history 命令查看镜像历史"></a>4. 使用 history 命令查看镜像历史</h4><p>​    使用 history 子命令， 该命令将列出各层的创建信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式：docker <span class="hljs-built_in">history</span> NAME[:TAG]<br></code></pre></td></tr></table></figure>

<h3 id="3-搜寻镜像"><a href="#3-搜寻镜像" class="headerlink" title="(3)搜寻镜像"></a>(3)搜寻镜像</h3><p>​    使用 docker search 命令可以搜索Docker Hub 官方仓库中的镜像，语法为 docker search [option] keyword。 支持的</p>
<p>命令选项主要包括：</p>
<p>​             –f, –filter filter: 过滤输出内容；</p>
<p>​             –format string: 格式化输出内容；</p>
<p>​             –limit int：限制输出结果个数， 默认为 25 个；</p>
<p>​             –no-trunc: 不截断输出结果。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">例如， 搜索官方提供的带 nginx关键字的镜像， 如下所示：<br>$ docker <span class="hljs-built_in">search</span> --<span class="hljs-built_in">filter</span>=<span class="hljs-keyword">is</span>-official=true nginx<br>再比如， 搜索所有收藏数超过 <span class="hljs-number">4</span> 的关键词包括 tensorflow 的镜像：<br>$ docker <span class="hljs-built_in">search</span> --<span class="hljs-built_in">filter</span>=stars=<span class="hljs-number">4</span> tensorflow<br></code></pre></td></tr></table></figure>

<h3 id="4-删除和清理镜像"><a href="#4-删除和清理镜像" class="headerlink" title="(4)删除和清理镜像"></a>(4)删除和清理镜像</h3><h4 id="1-使用标签删除镜像"><a href="#1-使用标签删除镜像" class="headerlink" title="1 使用标签删除镜像"></a>1 使用标签删除镜像</h4><p>​    使用 docker rmi 或 docker image rm 命令可以删除镜像, 命令格式为 docker rmi IMAGE [IMAGE … ], 其中 IMAGE可以为标签或 ID</p>
<p>​    支持选项包括：</p>
<p>​             -f, -force: 强制删除镜像， 即使有容器依赖它；</p>
<p>​             -no-prune: 不要清理未带标签的父镜像</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal">例如， 要删除掉 <span class="hljs-symbol">myubuntu:</span>latest镜像， 可以使用如下命令：<br><span class="hljs-variable">$ </span>docker rmi <span class="hljs-symbol">myubuntu:</span>latest<br>注：当同一个镜像拥有多个标签的时候，docker rmi 命令只是删除了该镜像多个标签中的指定标签而巳，并不影响镜像文件，但当镜像只剩下一个标签的时候就要小心了， 此时再使用 docker rmi 命令会彻底删除镜像<br></code></pre></td></tr></table></figure>

<h4 id="2-使用镜像ID来删除镜像"><a href="#2-使用镜像ID来删除镜像" class="headerlink" title="2. 使用镜像ID来删除镜像"></a>2. 使用镜像ID来删除镜像</h4><p>​    当使用 docker rmi 命令， 并且后面跟上镜像的 ID (也可以是能进行区分的部分 ID 串前缀）时， 会先尝试删除所有指向该镜像的标签，然后删除该镜像文件本身。</p>
<p>​    注意：当有该镜像创建的容器存在时， 镜像文件默认是无法被删除的</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">例如： 先利用ubuntu:latest镜像创建一个简单的容器来输出一段话：<br><span class="hljs-variable">$</span> docker run ubuntu:latest <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello! I am here!&#x27;</span><br>使用docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span>命令可以看到本机上存在的所有容器：<br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span><br>首先删除容器<br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">rm</span> <span class="hljs-number">740</span>b79cb85bf(容器ID)<br>然后使用ID来删除镜像<br><span class="hljs-variable">$</span> docker rmi <span class="hljs-number">3</span>dd93a811c95(镜像ID)<br>强行删除镜像,可以使用<span class="hljs-operator">-f</span>参数：<br><span class="hljs-variable">$</span> docker rmi <span class="hljs-operator">-f</span> NAME[:<span class="hljs-type">TAG</span>]<br></code></pre></td></tr></table></figure>

<p>​    注意：通常并不推荐使用 -f 参数来强制删除一个存在容器依赖的镜像。正确的做法是，先删除依赖该镜像的所有容器，再来删除镜像。</p>
<h4 id="3-清理镜像"><a href="#3-清理镜像" class="headerlink" title="3. 清理镜像"></a>3. 清理镜像</h4><p>​    使用Docker一段时间后，系统中可能会遗留一些临时的镜像文件，以及一些没有被使用的镜像，可以通过docker image prune命令来进行清理。</p>
<p>​    支待选项包括：</p>
<p>​         -a, -all: 删除所有无用镜像， 不光是临时镜像；</p>
<p>​         -filter filter: 只清理符合给定过滤器的镜像；</p>
<p>​         -f, -force: 强制删除镜像， 而不进行提示确认。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">例如， 如下命令会自动清理临时的遗留镜像文件层， 最后会提示释放的存储空间：<br><span class="hljs-variable">$</span> docker image prune <span class="hljs-operator">-f</span><br></code></pre></td></tr></table></figure>

<h3 id="5-创建镜像"><a href="#5-创建镜像" class="headerlink" title="(5)创建镜像"></a>(5)创建镜像</h3><p>​    创建镜像的方法主要有三种： 基于已有镜像的容器创建、 基千本地模板导入、 基于Dockerfile 创建。</p>
<h4 id="1-基于已有容器创建"><a href="#1-基于已有容器创建" class="headerlink" title="1.基于已有容器创建"></a>1.基于已有容器创建</h4><p>​    该方法主要是使用 docker [container] commit命令。命令格式为 docker [container] commit [OPTIONS] CONTAINER [REPOSITORY </p>
<p>[:TAG]], 主要选项包括：</p>
<p>​            -a, –author=””: 作者信息；</p>
<p>​            -c, - -change=[] : 提交的时候执行Dockerfile指令， 包括 CMD | ENTRYPOINT | ENV | EXPOSE | LABEL | ONBUILD | USER | VOLUME | WORKDIR等；</p>
<p>​            -m, - -message= “”: 提交消息；</p>
<p>​            -p, –pause=true: 提交时暂停容器运行。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs elixir">下面将演示如何使用该命令创建一个新镜像。<br><span class="hljs-number">1</span>、首先， 启动一个镜像， 并在其中进行修改操作。 例如，创建一个test文件，之后退出，代码如下：<br><span class="hljs-variable">$ </span>docker run -it <span class="hljs-symbol">ubuntu:</span>latest<br>root<span class="hljs-variable">@69a07111b6e2</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># touch test </span><br>root<span class="hljs-variable">@69a07111b6e2</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># exit</span><br><span class="hljs-number">2</span>、使用 docke [container] commit命令来提交为一个新的镜像。提交时可以使用 ID 或名称来指定容器：<br><span class="hljs-variable">$ </span>docker commit -m <span class="hljs-string">&quot;Added a new file&quot;</span> -a <span class="hljs-string">&quot;Docker Newbee&quot;</span> <span class="hljs-number">69</span>a07111b6e2 <span class="hljs-symbol">test:</span><span class="hljs-number">0.1</span><br>顺利的话， 会返回新创建镜像的 ID 信息， 例如<span class="hljs-symbol">sha256:</span>d204e29f522389df58f6098a9c74786960622d65903fc7bb7658dd41c63298f1<br><span class="hljs-number">3</span>、查看本地镜像列表， 会发现新创建的镜像已经存在了：<br><span class="hljs-variable">$ </span>docker images<br>REPOSITORY                    TAG       IMAGE ID       CREATED          SIZE<br>test                          <span class="hljs-number">0.1</span>       d204e29f5223   <span class="hljs-number">56</span> seconds ago   <span class="hljs-number">72.7</span>MB<br>nginx                         latest    f0b8a9a54136   <span class="hljs-number">28</span> hours ago     <span class="hljs-number">133</span>MB<br>ubuntu                        latest    <span class="hljs-number">7</span>e0aa2d69a15   <span class="hljs-number">2</span> weeks ago      <span class="hljs-number">72.7</span>MB<br>kitematic/hello-world-nginx   latest    <span class="hljs-number">03</span>b4557ad7b9   <span class="hljs-number">5</span> years ago      <span class="hljs-number">7.91</span>MB<br></code></pre></td></tr></table></figure>

<h4 id="2-基于本地模板导入"><a href="#2-基于本地模板导入" class="headerlink" title="2.基于本地模板导入"></a>2.基于本地模板导入</h4><p>​    直接从 个操作系统模板文件导人一个镜像，主要使用 docker [container]  import 命令 ，命令格式为 docker [image]  import    [OPTIONS]  file|URL|-[REPOSITORY[:TAG] ] </p>
<p>​    要直接导人一个镜像，可以使用 OpenVZ 提供的模板来创建，或者用其他已导出的镜像模板来创建 OPENVZ 模板的下载地址为<a href>http: //openvz.org/Download/templates/precreated</a></p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">例如，下载了 ubuntu-<span class="hljs-number">18.04</span> 的模板压缩包，之后使用以下命令导人即可：<br>$ cat ubuntu-<span class="hljs-number">18.04</span>-x86_64-minimal.tar.gz | docker import - ubuntu:<span class="hljs-number">18.04</span> <br>然后查看新导人的镜像，已经在本地存在了<br>$ docker images <br>REPOSITORY <span class="hljs-keyword">TAG</span> <span class="hljs-title">IMAGE</span> ID CREATED VIRTUAL SIZE <br>ubuntu <span class="hljs-number">18.04</span> <span class="hljs-number">05</span>ac7c0b9383 <span class="hljs-number">17</span> seconds ago <span class="hljs-number">215.5</span> MB<br></code></pre></td></tr></table></figure>

<h4 id="3-基于-Dockefile创建"><a href="#3-基于-Dockefile创建" class="headerlink" title="3.基于 Dockefile创建"></a>3.基于 Dockefile创建</h4><p>​    基于 ocke file 创建是最常见的方式 Dockerfile是一 个文本文件，利用给定的指令描述基于某个父镜像创建新镜像的过程</p>
<h3 id="6-存出和载人镜像"><a href="#6-存出和载人镜像" class="headerlink" title="(6)存出和载人镜像"></a>(6)存出和载人镜像</h3><h4 id="1-存出镜像"><a href="#1-存出镜像" class="headerlink" title="1.存出镜像"></a>1.存出镜像</h4><p>​    如果要导出镜像到本地文件，可以使用 docker [image] save 命令。该命令支持-o、-output string 参数导出镜像到指定的文件中</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">例如，导出本地的 ubuntu:l8.04 镜像为文件 ubuntu 18.04.tar 如下所示：<br>1、$ docker images <br>REPOSITORY                    TAG       IMAGE ID       CREATED          SIZE<br><span class="hljs-keyword">test                          </span>0.1       d204e29f5223   56 seconds ago   72.7MB<br>2、$ docker save -o test_0.1.tar test:0.1<br>之后，用户就可以通过复制 ubuntu 18.04.tar 文件将该镜像分享给他人<br></code></pre></td></tr></table></figure>

<h4 id="2-载入镜像"><a href="#2-载入镜像" class="headerlink" title="2.载入镜像"></a>2.载入镜像</h4><p>​    可以使用 docker [image] load 将导出的tar文件再导人到本地镜像库。支持 -i、-input string 选项，从指定文件中读人镜像内容</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">例如，从文件 test_0.<span class="hljs-number">1</span><span class="hljs-selector-class">.tar</span> 导人镜像到本地镜像列表，如下所示：<br>$ docker load -<span class="hljs-selector-tag">i</span> test_0.<span class="hljs-number">1</span><span class="hljs-selector-class">.tar</span><br>或者<br>$ docker load &lt; test_0.<span class="hljs-number">1</span>.tar<br></code></pre></td></tr></table></figure>

<h3 id="7-上传镜像"><a href="#7-上传镜像" class="headerlink" title="(7)上传镜像"></a>(7)上传镜像</h3><p>​    可以使用 docker [image] push 命令上传镜像到仓库，默认上传到 Docker Hub 官方仓库（需要登录） 命令格式为 docker [image] </p>
<p>push NAME[:TAG] | [REGISTRY_HOST [ :REGISTRY_PORT] / ]NAME [:TAG]</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">例如，用户 user 上传本地的 <span class="hljs-keyword">test</span> :latest 镜像，可以先添加新的标签 user/<span class="hljs-keyword">test</span>:latest 然后 docker [image] <span class="hljs-keyword">push</span> 令上传镜像<br>$ docker tag <span class="hljs-keyword">test</span>:latest user/<span class="hljs-keyword">test</span> : latest <br><br>docker <span class="hljs-keyword">push</span> user/<span class="hljs-keyword">test</span>:latest <br>The <span class="hljs-keyword">push</span> refers to a repository [docker<span class="hljs-number">.</span>io/user/<span class="hljs-keyword">test</span>] <br>Sending image list <br>Please login prior to <span class="hljs-keyword">push</span>: <br><span class="hljs-symbol">Username:</span> <br><span class="hljs-symbol">Password:</span> <br><span class="hljs-symbol">Email:</span><br></code></pre></td></tr></table></figure>

<p>​    注意：第一次上传时，会提示输入登录信息或进行注册，之后登录信息会记录到本地～/.docker目录下</p>
<h2 id="6、操作-Docker-容器"><a href="#6、操作-Docker-容器" class="headerlink" title="6、操作 Docker 容器"></a>6、操作 Docker 容器</h2><h3 id="1-创建容器"><a href="#1-创建容器" class="headerlink" title="(1)创建容器"></a>(1)创建容器</h3><h4 id="1-新建容器"><a href="#1-新建容器" class="headerlink" title="1. 新建容器"></a>1. 新建容器</h4><p>​        使用docker [container]  create [–name 别名]  NAME[:TAG]   命令新建一个容器，例如：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ docker <span class="hljs-built_in">create</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--name myubuntu ubuntu:latest</span><br>$ docker ps -<span class="hljs-keyword">a</span><br><br><span class="hljs-comment">--name: 指定容器名称</span><br>-p:指定容器端口号<br>-d:指定容器后台运行<br></code></pre></td></tr></table></figure>

<p>注意：使用 docker [container] create 命令新建的容器处于停止状态，可以使用 docker [container] start 命令来启动它</p>
<h4 id="2-启动容器"><a href="#2-启动容器" class="headerlink" title="2.启动容器"></a>2.启动容器</h4><p>​    使用 docker [container] start 命令来启动一个已经创建的容器</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">例如，启动创建的 ubuntu 容器<br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">start</span> 容器ID｜NAMES<br>通过 docker <span class="hljs-built_in">ps</span> 命令，可以查看到运行中的容器<br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span><br></code></pre></td></tr></table></figure>

<h4 id="3-新建井启动容器"><a href="#3-新建井启动容器" class="headerlink" title="3.新建井启动容器"></a>3.新建井启动容器</h4><p>​    除了创建容器后通 start 令来启动 也可直接新建并启动容器，所需要的命令主要为 docker [container ］run [-d -p 端口号 –name 别名]  NAME[:TAG] ，等价于先执行 docker [container] create 命令，再执行 docker [container] start 命令</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs stata">命令格式：docker [container］<span class="hljs-keyword">run</span> [-<span class="hljs-keyword">d</span> -p 端口号 --name 别名] NAME[:TAG] <br>例如，下面的命令输出一个“ Hello World&quot;,之后容器自动终止：<br>$ docker <span class="hljs-keyword">run</span> ubuntu /bin/echo ’Hello world&#x27; <br>Hello world<br><br>下面的命令启动一个 bash 终端，允许用户进行交互：<br>$ docker <span class="hljs-keyword">run</span> -it ubuntu:latest /bin/bash <br>root@afBbae53bdd3 /#<br>在交互模式下，用户可以通过所创建的终端来输人命令，例如：<br>root@13b5ba31fdde:/# <span class="hljs-keyword">pwd</span><br>/<br>root@13b5ba31fdde:/# <span class="hljs-keyword">ls</span><br>bin  <span class="hljs-keyword">boot</span>  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  <span class="hljs-keyword">run</span>  sbin  srv  sys  tmp  usr  <span class="hljs-keyword">var</span><br>root@13b5ba31fdde:/# ps<br>  PID TTY          TIME CMD<br>    1 pts/0    00:00:00 bash<br>   12 pts/0    00:00:00 ps<br>在容器内用 ps 命令查看进程，可以看到，只运行了 bash 应用，并没有运行其他无关的进程<br>用户可以按 Ctrl+<span class="hljs-keyword">d</span> 或输入 <span class="hljs-keyword">exit</span> 命令来退出容器：<br>root@13b5ba31fdde:/# <span class="hljs-keyword">exit</span><br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure>

<p>注：对于所创建的 bash 容器，当用户使用 exit 命令退出 bash 进程之后，容器也会自动退出。这是因为对于容器来说，当其中的应用退出后，容器的使命完成，也就没有继续运行的必要了。可以使用 docker container wait CONTAINER [CONTAINER . .. ］子命令来等待容器退出，并打印退出返回结果</p>
<h4 id="4-守护态运行"><a href="#4-守护态运行" class="headerlink" title="4.守护态运行"></a>4.守护态运行</h4><p>​    更多的时候，需要让 Docker 容器在后台以守护态（ Daemonized ）形式运行,此时，可以通过添加 -d 参数来实现</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">例如，下面的命令会在后台运行容器:<br>$ docker <span class="hljs-built_in">run</span> -d ubuntu:latest<br></code></pre></td></tr></table></figure>

<h4 id="5-查看容器输出"><a href="#5-查看容器输出" class="headerlink" title="5.查看容器输出"></a>5.查看容器输出</h4><p>​    要获取容器的输出信息，可以通过 docker [container] logs命令</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal">例如，查看某容器的输出可以使用如下命令<br><span class="hljs-variable">$ </span>docker logs 容器ID <br></code></pre></td></tr></table></figure>

<h3 id="2-停止容器"><a href="#2-停止容器" class="headerlink" title="(2)停止容器"></a>(2)停止容器</h3><h4 id="1-暂停容器"><a href="#1-暂停容器" class="headerlink" title="1. 暂停容器"></a>1. 暂停容器</h4><p>​    可以使用 docker [container] pause CONTAINER [CONTAINER … ］命令来暂停一个运行中的容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：docker pause 容器名｜容器ID<br>例如，启动一个容器，并将其暂停：<br><span class="hljs-meta">$ </span><span class="language-bash">docker run --name <span class="hljs-built_in">test</span> --<span class="hljs-built_in">rm</span> -it ubuntu bash</span> <br><span class="hljs-meta">$ </span><span class="language-bash">docker pause <span class="hljs-built_in">test</span></span> <br><span class="hljs-meta">$ </span><span class="language-bash">docker ps</span><br></code></pre></td></tr></table></figure>

<p>注意：处于 paused 状态的容器，可以使用 docker [contaier] unpause CONTAINER [CONTAINER …] 命令来恢复到运行状态</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">格式：docker unpause 容器名｜容器ID<br><span class="hljs-variable">$</span> docker unpause fervent_black<br>fervent_black<br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span><br>CONTAINER ID   IMAGE           COMMAND       CREATED          STATUS                   PORTS     NAMES<br>cee3155beed9   ubuntu:latest   <span class="hljs-string">&quot;/bin/bash&quot;</span>   <span class="hljs-number">37</span> minutes ago   Up <span class="hljs-number">30</span> minutes (Paused)             suspicious_bhabha<br><span class="hljs-number">69</span>a07111b6e2   ubuntu:latest   <span class="hljs-string">&quot;/bin/bash&quot;</span>   <span class="hljs-number">2</span> hours ago      Up <span class="hljs-number">26</span> minutes                      fervent_black<br></code></pre></td></tr></table></figure>

<h4 id="2-终止容器"><a href="#2-终止容器" class="headerlink" title="2.终止容器"></a>2.终止容器</h4><p>​    可以使用 docker [container] stop 来终止一个运行中的容器 该命令的格式为 docker stop  容器名｜容器ID</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta">格式：docker stop 容器名｜容器ID<br>执行 docker <span class="hljs-built_in">container</span> prune 命令，会自动清除掉所有处于停止状态的容器<br>还可以通过 docker [<span class="hljs-built_in">container</span>] kill 直接发送 SIGKILL 信号来强行终止容器<br>处于终止状态的容器，可以通过 docker [<span class="hljs-built_in">container</span>] start 命令来重新启动<br>通过 docker [<span class="hljs-built_in">container</span>] restart 命令会将一个运行态的容器先终止，然后再重新启动<br></code></pre></td></tr></table></figure>

<h3 id="3-进人容器"><a href="#3-进人容器" class="headerlink" title="(3)进人容器"></a>(3)进人容器</h3><p>​    在使用 -d 参数时，容器启动后会进入后台，用户无法看到容器中的信息，也无法进行操作,这个时候如果需要进入容器进行操作，推荐使用官方的 attach 或 exec 命令</p>
<h4 id="1-attach命令"><a href="#1-attach命令" class="headerlink" title="1.attach命令"></a>1.attach命令</h4><p>​    命令格式为：docker  [container]  attach  [–detach-keys[=[]]]  [–no-stdin]  [–sig-proxy[=true]]  CONTAINER </p>
<p>​    这个命令支持 个主要选项：</p>
<p>​        –detach-keys[=[]]：指定退出 attach 模式的快捷键序列， 默认是 CTRL-p、CTRL-q; </p>
<p>​        –no-stdin=true｜false ：是否关闭标准输入，默认是保持打开；</p>
<p>​        –sig-proxy=true｜false ：是否代理收到的系统信号给应用进程，默认为 true</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">下面示例如何使用该命令：<br>$ docker run -itd ubuntu<br><span class="hljs-number">3</span>bb7dc9da5b64aac1bf33b2ad7f25195d3cbad40430fa559f89724c7add8b42b<br>$ docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES<br><span class="hljs-number">3</span>bb7dc9da5b6   ubuntu    <span class="hljs-string">&quot;/bin/bash&quot;</span>   <span class="hljs-number">32</span> seconds ago   Up <span class="hljs-number">31</span> seconds             nervous_merkle<br>$ docker attach nervous_merkle|<span class="hljs-number">3</span>bb7dc9da5b6<br>root@<span class="hljs-number">3</span>bb7dc9da5b6:/<span class="hljs-comment"># exit</span><br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure>

<p>​    注意：使用 attach 命令有时候并不方便 当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示；当某个窗口因命令阻塞时，其他窗口也无法执行操作了</p>
<h4 id="2-exec-命令"><a href="#2-exec-命令" class="headerlink" title="2.exec 命令"></a>2.exec 命令</h4><p>​    可以在运行中容器内直接执行任意命令该命令的基本格式为：docker  [container]  exec  [-d｜-detach]  [detach-keys[=[]]]  [-i｜–interactive]  [–privileged]  [-t|–tty]  [-u|–user[=USER]]  CONTAINER  COMMAND [ARG… ] </p>
<p>比较重要的参数有：</p>
<p>​        -d, –detach 在容器中后台执行命令；</p>
<p>​        –detach-keys ＝＂＂：指定将容器切回后台的按键；</p>
<p>​        -e, –env= []：指定环境变量列表</p>
<p>​        -i, –interactive=true|false ：打开标准输入接受用户输入命令， 默认值为false; </p>
<p>​        –privileged=trueifalse 是否给执行命令以高权限，默认值为 false;</p>
<p>​        -t, –tty=true|false 分配伪终端，默认值为 false;</p>
<p>​        -u, –user ＝＂＂：执行命令的用户名或 ID</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">例如，进入到刚创建的容器中，并启动一个 bash:<br>$ docker exec -it 0e160368aa93 /bin/bash <br>root@0e160368aa93 :/<span class="hljs-comment">#</span><br>可以看到会打开一个新的 bash 终端，在不影响容器内其他应用的前提下，用户可以与容器进行交互<br>进一步地，可以在容器中查看容器中的用户和进程信息：<br>root@0e160368aa93:/<span class="hljs-comment"># w</span><br> 01:38:55 up  9:32, <span class="hljs-number"> 0 </span>users,  load average: 0.12, 0.06, 0.01<br>USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT<br>root@0e160368aa93:/<span class="hljs-comment"># ps -ef</span><br>UID        PID  PPID  C STIME TTY          TIME CMD<br>root        <span class="hljs-number"> 1 </span>   <span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span>01:36 pts/0    00:00:00 /bin/bash<br>root        <span class="hljs-number"> 9 </span>   <span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span>01:36 pts/1    00:00:00 /bin/bash<br>root       <span class="hljs-number"> 20 </span>   <span class="hljs-number"> 9 </span><span class="hljs-number"> 0 </span>01:39 pts/1    00:00:00 ps -ef<br></code></pre></td></tr></table></figure>

<h3 id="4-删除容器"><a href="#4-删除容器" class="headerlink" title="(4)删除容器"></a>(4)删除容器</h3><p>​    可以使用 docker  [container]  rm 命令来删除处于终止或退出状态的容器，命令格式为docker  [container)]  rm [-f|-force]  [-l|- link]  [-v|- volumes]  CONTAINER   [CONTAINER … ]</p>
<p>主要支持的选项包括:</p>
<p>​        -f, –force=false 是否强行终止并删除一个运行中的容器</p>
<p>​        -l, –link=false ：删除容器的连接 ，但保留容器；</p>
<p>​        -v, –volumes=false ：删除容器挂载的数据卷</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">例如，查看处于终止状态的容器，并删除:<br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span><br>CONTAINER ID   IMAGE           COMMAND       CREATED          STATUS                        PORTS     NAMES<br><span class="hljs-number">0</span>e160368aa93   ubuntu          <span class="hljs-string">&quot;/bin/bash&quot;</span>   <span class="hljs-number">8</span> minutes ago    Up <span class="hljs-number">8</span> minutes                            jolly_volhard<br><span class="hljs-number">3</span>bb7dc9da5b6   ubuntu          <span class="hljs-string">&quot;/bin/bash&quot;</span>   <span class="hljs-number">24</span> minutes ago   Exited (<span class="hljs-number">127</span>) <span class="hljs-number">18</span> minutes ago             nervous_merkle<br>bcbd19155264   ubuntu:latest   <span class="hljs-string">&quot;/bin/bash&quot;</span>   <span class="hljs-number">11</span> hours ago     Exited (<span class="hljs-number">127</span>) <span class="hljs-number">11</span> hours ago               bold_rosalind<br><br>默认情况下， docker <span class="hljs-built_in">rm</span> 命令只能删除已经处于终止或退出状态的容器，并不能删除还处于运行状态的容器<br>如果要直接删除 个运行中的容器，可以添加 <span class="hljs-operator">-f</span> 参数 Docker 会先发送 SIGKILL号给容器，终止其中的应用，之后强行删除:<br><span class="hljs-variable">$</span> docker run <span class="hljs-literal">-d</span> ubuntu:latest /bin/sh <span class="hljs-literal">-c</span> <span class="hljs-string">&quot;while true; do echo hello world;sleep 1;done&quot;</span><br>eb0ab7f929b0c37686f26925dbf4957b98d39646c67115d49cecc4707701c71c<br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">rm</span> eb0ab7f929b0c37686f26925dbf4957b98d39646c67115d49cecc4707701c71c<br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> eb0ab7f929b0c37686f26925dbf4957b98d39646c67115d49cecc4707701c71c<br>eb0ab7f929b0c37686f26925dbf4957b98d39646c67115d49cecc4707701c71c<br></code></pre></td></tr></table></figure>

<h3 id="5-导人和导出容器"><a href="#5-导人和导出容器" class="headerlink" title="(5)导人和导出容器"></a>(5)导人和导出容器</h3><h4 id="1-导出容器"><a href="#1-导出容器" class="headerlink" title="1.导出容器"></a>1.导出容器</h4><p>​    导出容器是指，导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态 可以使用 docker [container] export 令，该命令格式为：docker [container]  export [-o|–output [=“”]]  CONTAINER </p>
<p>其中，可以通过－ 选项来指定导出的 tar 文件名，也可以直接通过重定向来实现</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">新建一个容器：<br><span class="hljs-variable">$</span> docker run ubuntu:latest <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Hello World!&#x27;</span><br>查看所有的容器：<br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span><br>CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS                      PORTS     NAMES<br><span class="hljs-number">98635</span>f3ac6fb   ubuntu:latest   <span class="hljs-string">&quot;echo &#x27;hello! I am h…&quot;</span>   <span class="hljs-number">30</span> seconds ago   Exited (<span class="hljs-number">0</span>) <span class="hljs-number">29</span> seconds ago             happy_elion<br>导出<span class="hljs-number">98635</span>f3ac6fb容器到文件test_for_run.tar文件：<br><span class="hljs-variable">$</span> docker export <span class="hljs-literal">-o</span> test_for_run.tar <span class="hljs-number">98635</span>f3ac6fb <br><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span> <br>test_for_run.tar<br>之后，可将导出的 tar 文件传输到其他机器上，然后再通过导人命令导入到系统中，实现容器的迁移<br></code></pre></td></tr></table></figure>

<h4 id="2-导入容器"><a href="#2-导入容器" class="headerlink" title="2.导入容器"></a>2.导入容器</h4><p>​    导出的文件又可以使用 docker  [container]  import 命令导人变成镜像，该命令格式为 docker  import  [-c｜–change[=[]]]  [-m｜–message[=MESSAGE]]   file｜URL｜ -[REPOSITORY [:TAG]] </p>
<p>用户可以通过 c, –change＝[] 选项在导人的同时执行对容器进行修改的 Dockerfile指令</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">下面将导出的 test_0<span class="hljs-number">.1</span>.tar 文件导人到系统中：<br>$ docker import test_0<span class="hljs-number">.1</span>.tar test/ubuntu:vl.O<br>$ docker images<br>REPOSITORY   TAG       IMAGE ID       CREATED              SIZE<br>test         <span class="hljs-number">0.1</span>       <span class="hljs-number">82420b354058</span>   <span class="hljs-number">7</span> seconds ago        <span class="hljs-number">75.</span>1MB<br></code></pre></td></tr></table></figure>

<h3 id="6-查看容器"><a href="#6-查看容器" class="headerlink" title="(6)查看容器"></a>(6)查看容器</h3><h4 id="1-查看容器详情"><a href="#1-查看容器详情" class="headerlink" title="1.查看容器详情"></a>1.查看容器详情</h4><p>​        查看容器详情可以使用 docker  container  inspect  [OPTIONS] CONTAINER  [CONTAINER . .. ]子命令</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">例如，查看某容器的具体信息，会以 <span class="hljs-keyword">json </span>格式返回包括容器 Id 创建时间、路径、状态、镜像、配置等在内的各项信息：<br>$ docker container <span class="hljs-keyword">inspect </span>test<br></code></pre></td></tr></table></figure>

<h4 id="2-查看容器内进程"><a href="#2-查看容器内进程" class="headerlink" title="2. 查看容器内进程"></a>2. 查看容器内进程</h4><p>​    查看容器内进程可以使用 docker  [container]  top  [OPTIONS] CONTAINER  [CONTAINER…] 子命令</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">命令格式：docker <span class="hljs-built_in">top</span> NAME|<span class="hljs-type">ID</span><br>例如，查看某容器内的进程信息，命令如下：<br>$ docker <span class="hljs-built_in">top</span> webserver<br></code></pre></td></tr></table></figure>

<h4 id="3-查看统计信息"><a href="#3-查看统计信息" class="headerlink" title="3.查看统计信息"></a>3.查看统计信息</h4><p>​    查看统计信息可以使用 docker  [container]  stats  [OPTIONS] [CONTAINER … ] 子命令，会显示 CPU、内存、存储、网络等使用情况的统计信息</p>
<p>​    支持选项包括：</p>
<p>​        -a, -all ：输出所有容器统计信息，默认仅在运行中；</p>
<p>​        -format string ：格式化输出信息；</p>
<p>​        -no-stream ：不持续输出，默认会自动更新持续实时结果；</p>
<p>​        -no-trunc ：不截断输出信息</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">例如，查看当前运行中容器的系统资源使用统计：<br>$ docker stats<br>CONTAINER ID   NAME        CPU %     MEM USAGE <span class="hljs-regexp">/ LIMIT     MEM %     NET I/</span>O         BLOCK I/O        PIDS<br><span class="hljs-number">698</span>a564c7cce   webserver   <span class="hljs-number">0.00</span>%     <span class="hljs-number">2.227</span>MiB <span class="hljs-regexp">/ 1.942GiB   0.11%     1.74kB /</span> <span class="hljs-number">448</span>B   <span class="hljs-number">700</span>kB / <span class="hljs-number">8.19</span>kB   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h3 id="7-其他容器命令"><a href="#7-其他容器命令" class="headerlink" title="(7)其他容器命令"></a>(7)其他容器命令</h3><h4 id="1-复制文件"><a href="#1-复制文件" class="headerlink" title="1. 复制文件"></a>1. 复制文件</h4><p>​    container cp 命令支持在容器和主机之间复制文件 命令格式为 docker  [container]  cp  [OPTIONS]  CONTAINER:SRC_PATH  DEST_PATH｜-</p>
<h5 id="命令：docker-cp-容器ID-容器内路径-目的主机路径"><a href="#命令：docker-cp-容器ID-容器内路径-目的主机路径" class="headerlink" title="命令：docker cp 容器ID:容器内路径 目的主机路径"></a>命令：docker cp 容器ID:容器内路径 目的主机路径</h5><p>支持的选项包括：</p>
<p>​        -a, -ar chive ：打包模式，复制文件会带有原始的 uid/gid 信息；</p>
<p>​        -L, -follow-link ：跟随软连接。当原路径为软连接时,默认只复制链接信息，使用该选项会复制链接的目标内容</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell">例如，将本地的路径 <span class="hljs-class"><span class="hljs-keyword">data</span> 复制到 myubuntu 容器的／tmp 路径下</span><br>$ docker container cp <span class="hljs-class"><span class="hljs-keyword">data</span> myubuntu:/tmp/</span><br></code></pre></td></tr></table></figure>

<h4 id="2-查看变更"><a href="#2-查看变更" class="headerlink" title="2. 查看变更"></a>2. 查看变更</h4><p>​    container diff 看容器内文件系统的变更，命令格式为 docker [container] diff CONTAINER</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">例如，查看 myubuntu 容器内的数据修改：<br><span class="hljs-variable">$</span> docker container <span class="hljs-built_in">diff</span> myubuntu<br>C /tmp<br>A /tmp/<span class="hljs-keyword">data</span><br></code></pre></td></tr></table></figure>

<h4 id="3-查看端口映射"><a href="#3-查看端口映射" class="headerlink" title="3.查看端口映射"></a>3.查看端口映射</h4><p>​    container port 命令可以查看容器的端口映射’情况 命令格式为 docker [container] port NAME|ID  [PRIVATE_PORT[/PROTO]］</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xl">例如，查看 webserver 容器的端口映射情况：<br>$ docker container port webserver<br><span class="hljs-number">80</span>/<span class="hljs-function"><span class="hljs-title">tcp</span> -&gt;</span> <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">80</span><br><span class="hljs-number">80</span>/<span class="hljs-function"><span class="hljs-title">tcp</span> -&gt;</span> :::<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>

<h4 id="4-更新配置"><a href="#4-更新配置" class="headerlink" title="4. 更新配置"></a>4. 更新配置</h4><p>​    container update 命令可以更新容器的一些运行时配置，主要是一些资源限制份额。</p>
<p>​    命令格式为 docker  [container]  update [OPTIONS] CONTAINER  [CONTAINER…]</p>
<p>支持的选项包括：</p>
<p>​        －blkio-weight uintl6 ：更新块 IO 限制，101000，默认值为，代表着无限制；</p>
<p>​        －cpu-period int ：限制 CPU 调度器 CFS (Completely Fair Scheduler ）使用时间，单位为微秒，最小1000;</p>
<p>​        －cpu-quota int ：限制 CPU 调度器 CFS 配额，单位为微秒，最小 1000;</p>
<p>​        －cpu-rt period int ：限制 CPU 调度器的实时周期，单位为微秒</p>
<p>​        －cpu-rt runtime int ：限制 CPU 调度器的实时运行时，单位为微秒；</p>
<p>​        －c, -cpu-shares in 限制 CPU 使用份额；</p>
<p>​        －cpus decimal ：限制 CPU 个数；</p>
<p>​        －cpuset-cpus string ：允许使用的 CPU 核，如 0-3, 0,1; </p>
<p>​        －cpuset mems string ：允许使用的内存块，如 0-3’ 0, 1; </p>
<p>​        －kernel-memor bytes ：限制使用的内核内存；</p>
<p>​        －m, -memory bytes 限制使用的内存；</p>
<p>​        －memory-reservation bytes ：内存软限制；</p>
<p>​        －memory-swap bytes ：内存加上缓存区的限制，-1 表示为对缓冲区无限制；</p>
<p>​        －restart stri 口g 容器退出后的重启策略</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">例如，限制总配额为<span class="hljs-number">1</span>秒，容器 webserver 所占用时间为<span class="hljs-number">10</span><span class="hljs-operator">%</span> ，代码如下所示：<br>$ docker <span class="hljs-keyword">update</span> <span class="hljs-comment">--cpu-quota 1000000 webserver </span><br>webserver <br>$ docker <span class="hljs-keyword">update</span> <span class="hljs-comment">--cpu-period 100000 webserver </span><br>webserver<br></code></pre></td></tr></table></figure>



<h2 id="7-访问-Docker-仓库"><a href="#7-访问-Docker-仓库" class="headerlink" title="7.访问 Docker 仓库"></a>7.访问 Docker 仓库</h2><h3 id="1-Docker-Hub-公共镜像市场"><a href="#1-Docker-Hub-公共镜像市场" class="headerlink" title="(1)Docker Hub 公共镜像市场"></a>(1)Docker Hub 公共镜像市场</h3><p>​    Docker Hub Docker 官方提供的最大的公共镜像仓库，目前包括了超过 100000像，地址为 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h4 id="1-登录"><a href="#1-登录" class="headerlink" title="1. 登录"></a>1. 登录</h4><p>​    可以通过命令行执行 docker login 命令来输入用户名 密码和邮箱来完成注册和登录。注册成功后，本地用户目录下会自动创建 docker config on 文件，保存用户的认证信息。</p>
<p>​    登录成功的用户可以上传个人制作的镜像到 Docker Hub</p>
<h4 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h4><p>​    用户无须登录即可通过 docker search 命令来查找官方仓库中的镜像，并利用 docker  [image]  pull 命令来将它下载到本地</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">例如以 centos 为关键词进行搜索<br>$ docker search centos<br><br>根据是否为官方提供，可将这些镜像资源分为两类：<br>	<span class="hljs-number">1</span>.一种是类似于 centos 这样的基础镜像，也称为根镜像 这些镜像是由 Docker 公司创建、验证、支持、提供 ，这样的镜像往往使用单个单词作为名字；<br>	<span class="hljs-number">2</span>.一种类型的镜像，比如 an sible centos7-ansible 镜像，是由 Docker 用户ansible 创建并维护的，带有用户名称为前缀，表明是某用户下的某仓库 可以通过用户名称前缀“ <span class="hljs-keyword">user</span> <span class="hljs-title">name</span>／镜像名”来指定使用某个用户提供的镜像<br>下载官方 centos 镜像到本地，代码如下所示：<br>$ docker pull centos<br>用户也可以在登录后通过 docker push 命令来将本地镜像推送到 Docker Hub<br></code></pre></td></tr></table></figure>

<h4 id="3-自动创建"><a href="#3-自动创建" class="headerlink" title="3. 自动创建"></a>3. 自动创建</h4><p>​    例如，用户构建了某应用镜像，如果应用发布新版本，用户需要手动更新镜像。而自动创建则允许用户通过 Docker Hub 指定跟踪一个目标网站（目前支持 GitHub BitBucket ）上的项目，一旦项目发生新的提交，则自动执行创建。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">要配置自动创建，包括如下的步骤：<br><span class="hljs-number">1</span>）创建并登录 Docker Hub ，以及目标网站如 Github<span class="hljs-comment">;</span><br><span class="hljs-number">2</span>）在目标网站中允许 Docker Hub 访问服务；<br><span class="hljs-number">3</span>）在 Docker Hub 中配置一个“自动创建”类型的项目；<br><span class="hljs-number">4</span>）选取一个目标网站中的项目（需要含 Dockerfile ）和分支；<br><span class="hljs-number">5</span>）指定 Dockerfile 的位置，并提交创建<br>之后，可以在 Docker Hub 的“自动创建”页面中跟踪每次创建的状态<br></code></pre></td></tr></table></figure>

<h3 id="2-第三方镜像市场"><a href="#2-第三方镜像市场" class="headerlink" title="(2)第三方镜像市场"></a>(2)第三方镜像市场</h3><h4 id="1-查看镜像"><a href="#1-查看镜像" class="headerlink" title="1.查看镜像"></a>1.查看镜像</h4><p>​    访问 <a target="_blank" rel="noopener" href="https://hub.tenxcloud.com/">https://hub.tenxcloud.com</a> ，即可看到己存在的仓库和存储的镜像，包括 Ubuntu、Java、Mongo、MySQL、Nginx 等热 门仓库和镜像，时速云官方仓库中的镜像会保持与Docker Hub 中官方镜像的同步</p>
<h4 id="2-下载镜像"><a href="#2-下载镜像" class="headerlink" title="2. 下载镜像"></a>2. 下载镜像</h4><p>​    下载镜像也是使用 docker pull 命令，但是要在镜像名称前添加注册服务器的具体地址。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">格式为 index.tenxcloud/com/<span class="hljs-tag">&lt;namespace&gt;</span>/<span class="hljs-tag">&lt;repository&gt;</span><span class="hljs-tag">&lt;:tag&gt;</span><br>例如，要下载 Docker 官方仓库中的 <span class="hljs-keyword">node</span><span class="hljs-title">:latest</span> 镜像，可以使用如下命令<br>$ docker pull index.tenxcloud.com/docker_library/<span class="hljs-keyword">node</span><span class="hljs-title">:latest</span><br>下载后，可以更新镜像的标签，与官方标签保持一致，方便使用：<br>$ docker <span class="hljs-keyword">tag</span> <span class="hljs-title">index</span>.tenxcloud.com/docker_library/<span class="hljs-keyword">node</span><span class="hljs-title">:latest</span> <span class="hljs-keyword">node</span><span class="hljs-title">:latest</span><br></code></pre></td></tr></table></figure>

<h4 id="3-搭建本地私有仓库"><a href="#3-搭建本地私有仓库" class="headerlink" title="3 搭建本地私有仓库"></a>3 搭建本地私有仓库</h4><h4 id="1-使用-registry-镜像创建私有仓库"><a href="#1-使用-registry-镜像创建私有仓库" class="headerlink" title="(1)使用 registry 镜像创建私有仓库"></a>(1)使用 registry 镜像创建私有仓库</h4><p>​    安装 docker 可以通过官方提供的 registry 镜像来简单搭建一套本地私有仓库环境：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ docker run -d -p <span class="hljs-number">5000</span>:<span class="hljs-number">5000</span> registry:<span class="hljs-number">2</span> <br>这将自动下载井启动一个 registry 容器，创建本地的私有仓库服务<br>默认情况下，仓库会被创建在容器的／var<span class="hljs-regexp">/lib/</span>regis町目录下 可以通过 -v 参数来将镜像文件存放在本地的指定路径<br>例如,下面的例子将上传的镜像放到<span class="hljs-regexp">/opt/</span>data/registry 目录：<br>$ docker run -d -p <span class="hljs-number">5000</span>:<span class="hljs-number">5000</span> -v<span class="hljs-regexp">/opt/</span>data<span class="hljs-regexp">/registry:/</span>var<span class="hljs-regexp">/lib/</span>registry registry:<span class="hljs-number">2</span> <br>此时，在本地将启动一个私有仓库服务，监听端口为 <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure>

<h4 id="2-管理私有仓库"><a href="#2-管理私有仓库" class="headerlink" title="(2)管理私有仓库"></a>(2)管理私有仓库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">使用 docker tag 命令将这个镜像标记为 10.0.2.2:5000/test（格式为 docker tag IMAGE[:TAG] [REGISTRY.HOST/] [USERNAME/] NAME[:TAG ］）<br><span class="hljs-meta">$ </span><span class="language-bash">docker tag ubuntu:latest 10.0.2.2:5000/test</span><br>使用 docker push 上传标记的镜像：<br><span class="hljs-meta">$ </span><span class="language-bash">docker push 10.0.2.2:5000/test</span><br>使curl 查看仓库工 10.0.2.2:5000 中的镜像：<br><span class="hljs-meta">$ </span><span class="language-bash">curl http://10.0.2.2:5000/v2/search</span><br>在结果中可以看到｛＂ description&quot;: ’t II / II ame11 11library/test11 ｝，表明镜像已经成功上传了<br>现在可以到任意 台能访问到工 0.0.2.2 地址的机器去下载这个镜像了<br>比较新的 Docker 版本对安全性要求较高，会要求仓库支持 SSL/TLS 证书。对于内部使用的私有仓库，可以自行配置证书或关闭对仓库的安全性检查<br>首先，修改 Docker daemon 的启动参数，添加如下参数，表示信任这个私有仓库，不进行安全证书检查：<br>	DOCKER_OPTS;”--insecure-registry 10.0.2.2:500 。”<br>之后重启 Docker 服务，并从私有仓库中下载镜像到本地：<br><span class="hljs-meta">$ </span><span class="language-bash">sudo service docker restart</span> <br><span class="hljs-meta">$ </span><span class="language-bash">docker pull 10.0.2.2:5000/test</span><br>下载后，还可以添加一个更通用的标签 ubuntu:18.04 ，方便后续使用<br><span class="hljs-meta">$ </span><span class="language-bash">docker tag 10.0.2.2:5000/test ubuntu:18.04</span><br></code></pre></td></tr></table></figure>

<h2 id="8-Docker-数据管理"><a href="#8-Docker-数据管理" class="headerlink" title="8.Docker 数据管理"></a>8.Docker 数据管理</h2><h3 id="1-数据卷"><a href="#1-数据卷" class="headerlink" title="(1)数据卷"></a>(1)数据卷</h3><p>​    数据卷 (Data Volumes) 是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于 Linux 中的 mount 行为</p>
<p>​    数据卷可以提供很多有用的特性：</p>
<p>​            数据卷可以在容器之间共事和重用，容器间传递数据将变得高效与方便；</p>
<p>​            对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作；</p>
<p>​            对数据卷的更新不会影响镜像，解摘开应用和数据</p>
<p>​            卷会一直存在 ，直到没有容器使用，可以安 地卸载它</p>
<h4 id="1-创建数据卷"><a href="#1-创建数据卷" class="headerlink" title="1. 创建数据卷"></a>1. 创建数据卷</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Docker 提供了 volume 子命令来管理数据卷，如下命令可以快速在本地创建一个数据卷：<br>$ docker volume create -d local test<br><span class="hljs-keyword">test</span><br><span class="hljs-keyword"></span>查看 /var/lib/docker/volumes 路径下，会发现所创建的数据卷位置<br>$ ls -l /var/lib/docker/volumes<br>除了 create 子命令外， docker volume 还支持 inspect（查看详细信息）、ls（列出已有数据卷）、prune（清理无用数据卷）、rm（删除数据卷）等<br></code></pre></td></tr></table></figure>

<h4 id="2-绑定数据卷"><a href="#2-绑定数据卷" class="headerlink" title="2.绑定数据卷"></a>2.绑定数据卷</h4><p>​    除了使用 volume 子命令来管理数据卷外，还可以在创建容器时将主机本地的任意路径挂载到容器内作为数据卷，这种形式创建的数据卷称为绑定数据卷</p>
<p>​    在用 docker [container] run 命令的时候，可以使用 -mount 选项来使用数据卷</p>
<p>​    -mount 项支持三种类型的数据卷，包括</p>
<p>​            volume 普通数据卷，映射到主机 /var/lib/docker/volumes 径下；</p>
<p>​            bind ：绑定数据卷，映射到主机指定路径下；</p>
<p>​            tmpfs ：临时数据卷，只存在于内存中</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">使用 training/webapp 镜像创建 Web 容器，并创建一个数据卷挂载到容器的 /opt/webapp 目录：<br>$ docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -p --name web --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=/webapp,destination=/opt/webapp training/webapp python app.py</span><br>上述命令等同于使用旧的 标记可以在容器内创建一个数据卷：<br>$ docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -p --name web -v /webapp:/opt/webapp training/webapp python app.py</span><br>注：这个功能在进行应用测试的时候十分方便，比如用户可以放置一些程序或数据到本地目录中实时进行更新，然后在容器 运行和使用；另外，本地目录的路径必须是绝对路径，容器内路径可以为相对路径 如果目录不存在， Docker 会自动创建<br>Docker 载数据卷的默认权限是读写 (rw) ，用户也可以通过 ro 指定为只读<br>$ docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -p --name web -v /webapp:/opt/webapp:ro training/webapp python app.py</span><br>加了： ro 之后，容器内对所挂载数据卷内的数据就无法修改了<br>如果直接挂载一个文件到容器，使用文件编辑工具，包括 vi 或者 sed --in-place 的时候，可能会造成文件 inode 的改 Docker <span class="hljs-number">1.1</span>.<span class="hljs-number">0</span> 起，这会导致报错误信息 所以推荐的方式是直接挂载文件所在的目录到容器内。<br></code></pre></td></tr></table></figure>

<h3 id="2-数据卷容器"><a href="#2-数据卷容器" class="headerlink" title="(2)数据卷容器"></a>(2)数据卷容器</h3><p>​    如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门提供数据卷给其他容器挂载。</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs tcl">首先，创建一个数据卷容器 dbdata 并在其中创建一个数据卷挂载到 /dbdata:<br>$ docker run -it -v /dbdata --name dbdata ubuntu<br>查看／dbdata 目录<br>root@<span class="hljs-number">60</span>b27bcd3b34:/# ls<br>bin  boot  dbdata  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  <span class="hljs-keyword">proc</span><span class="hljs-title">  root</span> <span class="hljs-title"> run</span> <span class="hljs-title"> sbin</span> <span class="hljs-title"> srv</span> <span class="hljs-title"> sys</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> usr</span> <span class="hljs-title"> var</span><br>然后，可以在其他容器中使用 --volumes-from 来挂载dbdata容器中的数据卷，例如创建dbl和db2两个容器，并从dbdata容器挂载数据卷：<br>$<span class="hljs-title"> docker</span> run -it --volumes-from<span class="hljs-title"> dbdata</span> --name<span class="hljs-title"> dbl</span> ubuntu <br>$<span class="hljs-title"> docker</span> run -it --volumes-from<span class="hljs-title"> dbdata</span> --name<span class="hljs-title"> db2</span> ubuntu<br>此时，容器<span class="hljs-title"> dbl和db2</span> 都挂载同一个数据卷到相同的 /dbdata 目录，三个容器任何一方在该目录下的写人，其他容器都可以看到<br>例如，在<span class="hljs-title"> dbdata</span> 容器中创建一个<span class="hljs-title"> test</span> 文件：<br>进入容器：$<span class="hljs-title"> docker</span> attach<span class="hljs-title"> dbdata</span><br>编译：root@60b27bcd3b34:/#<span class="hljs-title"> cd</span> /dbdata<span class="hljs-title"></span><br><span class="hljs-title">		 root@60b27bcd3b34:/dbdata#</span> touch<span class="hljs-title"> test</span><br><span class="hljs-title">		 root@60b27bcd3b34:/dbdata#</span> ls<span class="hljs-title"></span><br><span class="hljs-title">		 test</span><br>		 在<span class="hljs-title"> dbl</span> 容器内查看它：<br>		 $<span class="hljs-title"> docker</span> attach<span class="hljs-title"> db1的ID</span><br><span class="hljs-title">		 root@fc47426f1c5b:/#</span> ls /dbdata<span class="hljs-title"></span><br><span class="hljs-title">		 test</span><br>可以多次使用 --volumes-from 参数来从多个容器挂载多个数据卷，还可以从其他已经挂载了容器卷的容器来挂载数据卷<br>$<span class="hljs-title"> docker</span> run -d --name<span class="hljs-title"> db3</span> --volumes-from<span class="hljs-title"> dbl</span> training/postgres<br><br>注意：使用 --volumes-from 参数所挂载数据卷的容器自身并不需要保持在运行状态<br></code></pre></td></tr></table></figure>

<p>注意：如果删除了挂载的容器（包括 dbdata db 工和 db2 ），数据卷并不会被自动删除，如果删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用 docker rm -v 令来指定同时删除关联的容器</p>
<h3 id="3-利用数据卷容器来迁移数据"><a href="#3-利用数据卷容器来迁移数据" class="headerlink" title="(3)利用数据卷容器来迁移数据"></a>(3)利用数据卷容器来迁移数据</h3><p>​    可以利用数据卷容器对其中的数据卷进行备份、恢复，以实现数据的迁移</p>
<h4 id="1-备份"><a href="#1-备份" class="headerlink" title="1. 备份"></a>1. 备份</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">使用下面的命令来备份 dbdata 数据卷容器内的数据卷<br>$ docker run -volumes-<span class="hljs-keyword">from</span> dbdata -v $(pwd):<span class="hljs-regexp">/backup - -name worker ubuntu tar cvf /</span>backup<span class="hljs-regexp">/backup.tar /</span>dbdata<br>这个命令稍微有点复杂，具体分析下:<br>首先利用 buntu 镜像创建了一个容器 worker 使用 --volumes-<span class="hljs-keyword">from</span> dbdata 参数来让 worker 容器挂载 dbdata 容器的数据卷（dbdata数据卷）；使用 -$(pwd):<span class="hljs-regexp">/backup 参数来挂载本地的当前目录到 worker 容器的 /</span>backup 目录。<br>worker 容器启动后，使用 tar cvf <span class="hljs-regexp">/backup/</span>backup.tar <span class="hljs-regexp">/dbdata 令将 /</span>dbdata 下内容备份为容器内的／backup/backup.tar，即宿主主机当前目录下的 backup.tar<br></code></pre></td></tr></table></figure>

<h4 id="2-恢复"><a href="#2-恢复" class="headerlink" title="2. 恢复"></a>2. 恢复</h4><p>​    如果要恢复数据到一个容器，可以按照下面的操作</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">首先创建一个带有数据卷的容器 bdata2:<br>$ docker <span class="hljs-keyword">run</span><span class="language-bash"> -v /dbdata --name dbdata2 ubuntu /bin/bash </span><br>然后创建另一个新的容器，挂载 dbdata2 容器，并使用 untar 解压备份文件到所挂载的容器卷中：<br>$docker <span class="hljs-keyword">run</span><span class="language-bash"> --volumes-from dbdata2 -v $(<span class="hljs-built_in">pwd</span>) :/backup busybox tar xvf /backup/backup.tar</span><br></code></pre></td></tr></table></figure>





<h2 id="9-端口映射与容器互联"><a href="#9-端口映射与容器互联" class="headerlink" title="9.端口映射与容器互联"></a>9.端口映射与容器互联</h2><p>​    Docker 除了通过网络访间外， 还提供了两个很方便的功能来满足服务访问的基本需求：一个是允许映射容器内应用的服务端口到本地宿主主机；另一个是互联机制实现多个容器间通过容器名来快速访问</p>
<h3 id="1-端口映射实现容器访问"><a href="#1-端口映射实现容器访问" class="headerlink" title="(1)端口映射实现容器访问"></a>(1)端口映射实现容器访问</h3><h4 id="1从外部访问容器应用"><a href="#1从外部访问容器应用" class="headerlink" title="1从外部访问容器应用"></a>1从外部访问容器应用</h4><p>​    在启动容器的时候， 如果不指定对应参数， 在容器外部是无法通过网络来访问容器内的网络应用和服务的。当容器中运行一些网络应用， 要让外部访问这些应用时， 可以通过 -P 或 -p 参数来指定端口映射。当使用平（大写的）标记时， Docker 会随机映 49000～49900 的端口到内部容器开放的网络端口：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker run <span class="hljs-literal">-d</span> <span class="hljs-literal">-P</span> training/webapp python app.py <br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-l</span><br></code></pre></td></tr></table></figure>

<p>​    此时， 可以使用 docker ps 看到， 本地主机的 49155 被映射到了容器的 5000 端口。访间宿主主机的 49155 端口即可访问容器内 web 应用提供的界面。同样， 可以通过 docker logs 命令来查看应用的信息：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker logs <span class="hljs-operator">-f</span> nostalgic_morse<br></code></pre></td></tr></table></figure>

<p>​    -p (小写的）则可以指定要映射的端口，并且，在一个指定端口上只可以绑定 一个容器。支持的格式有 IP:HostPort:ContainerPort | IP:: ContainerPort | HostPart:ContainerPort。</p>
<h4 id="2-映射所有接口地址"><a href="#2-映射所有接口地址" class="headerlink" title="2.映射所有接口地址"></a>2.映射所有接口地址</h4><p>​    使用 HostPort:ContainerPort 格式本地的5000端口映射到容器的5000端口，可以执行如下命令：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -p 5000:5000 training/webapp python app.py</span><br>此时默认会绑定本地所有接口上的所有地址。多次使用-p标记可以绑定多个端口。例如：<br>$ docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -p 5000:5000 -p 3000:80 training/webapp python app.py</span><br></code></pre></td></tr></table></figure>

<h4 id="3-映射到指定地址的指定端口"><a href="#3-映射到指定地址的指定端口" class="headerlink" title="3.映射到指定地址的指定端口"></a>3.映射到指定地址的指定端口</h4><p>​    可以使用 IP:HostPart:ContainerPort 格式指定映射使用一个特定地 址，比如 localhost地址127.0.0.1:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">$ docker run -d -p <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">5000:5000</span> training/webapp python app.py<br></code></pre></td></tr></table></figure>

<h4 id="4-映射到指定地址的任意端口"><a href="#4-映射到指定地址的任意端口" class="headerlink" title="4.映射到指定地址的任意端口"></a>4.映射到指定地址的任意端口</h4><p>​    使用IP::ContainerPort 绑定localhost的任意端口到容器的5000端口，本地主机会自动分配一个端口：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">$ docker run -d -p <span class="hljs-number">127.0.0.1</span><span class="hljs-number">::5000</span> training/webapp python app.py<br></code></pre></td></tr></table></figure>

<p>​    还可以使用udp标记来指定 udp端口：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br></code></pre></td></tr></table></figure>

<h4 id="5-查看映射端口配置"><a href="#5-查看映射端口配置" class="headerlink" title="5.查看映射端口配置"></a>5.查看映射端口配置</h4><p>​    使用docker port来查看当前映射的端口配置，也可以查看到绑定的地址:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>docker port nostalgic_rnorse <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure>

<p>注意：容器有自己的内部网络和IP地址，使用docker [container]  inspect＋容器ID. 可以获取容器的具体信息</p>
<h3 id="2-互联机制实现便捷互访"><a href="#2-互联机制实现便捷互访" class="headerlink" title="(2)互联机制实现便捷互访"></a>(2)互联机制实现便捷互访</h3><p>​    容器的互联(Iinking)是一种让多个容器中的应用进行快速交互的方式。它会在源和接收容器之间创建连接关系，接收容器可以通过容器名快速访问到源容器，而不用指定具体的IP地址。</p>
<h4 id="1-自定义容器命名"><a href="#1-自定义容器命名" class="headerlink" title="1.自定义容器命名"></a>1.自定义容器命名</h4><p>​    连接系统依据容器的名称来执行。因此，首先需要自定义一个好记的容器命名。虽然当创建容器的时候，系统默认会分配一个名字，但自定义命名容器有两个好处：</p>
<p>​        1、自定义的命名，比较好记，比如一个Web应用容器我们可以给它起名叫web, 一 目了然；</p>
<p>​        2、当要连接其他容器时候（即便重启），也可以使用容器名而不用改变，比如连接web容器到db容器。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">使用--name标记可以为容器自定义命名：<br>$ docker <span class="hljs-keyword">run</span> -<span class="hljs-keyword">d</span> -P --name web training/webapp py七hon <span class="hljs-keyword">app</span>.py <br>使用docker ps来验证设定的命名：<br>$ docker ps -1<br>也可以使用docker [container) <span class="hljs-keyword">inspect</span>来查看容器的名字：<br>$ docker [container) <span class="hljs-keyword">inspect</span> -f <span class="hljs-string">&quot;&#123;&#123;.Name&#125;&#125;&quot;</span> 容器ID<br>在执行docker [container] <span class="hljs-keyword">run</span>的时候如果添加--<span class="hljs-keyword">rm</span>标记，则容器在终止后会立刻删除。注意，--<span class="hljs-keyword">rm</span> 和-<span class="hljs-keyword">d</span>参数不能同时使用。<br></code></pre></td></tr></table></figure>

<p>注意：容器的名称是唯一的。如果巳经命名了一个叫web的容器，当你要再次使用 web 这个名称的时候，需要先用docker rm命令删除之前创建的同名容器。</p>
<h4 id="2-容器互联"><a href="#2-容器互联" class="headerlink" title="2.容器互联"></a>2.容器互联</h4><p>​    使用 –link参数可以让容器之间安全地进行交互。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stata">先创建一个新的数据库容器：<br>$ docker <span class="hljs-keyword">run</span> -<span class="hljs-keyword">d</span> --name <span class="hljs-keyword">db</span> training/postgres<br>删除之前创建的web容器：<br>$ docker <span class="hljs-keyword">rm</span> -f web <br>然后创建一个新的web容器，并将它连接到<span class="hljs-keyword">db</span>容器：<br>$ docker <span class="hljs-keyword">run</span> -<span class="hljs-keyword">d</span> -P --name web --link <span class="hljs-keyword">db</span>:<span class="hljs-keyword">db</span> taining/webapp python <span class="hljs-keyword">app</span>.py<br>此时，<span class="hljs-keyword">db</span>容器和web容器建立互联关系。<br>--link参数的格式为 --link name:alias, 其中name是要链接的容器的名称，alias是别名<br>使用 docker ps 来查看容器的连接：<br>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES <br>$ docker ps<br>349169744e49 training/postgres:latest <span class="hljs-keyword">su</span> postgres -c &#x27;/usr <span class="hljs-keyword">About</span> a minute ago <br>Up <span class="hljs-keyword">About</span> a minute 5432/tcp <span class="hljs-keyword">db</span>, web/<span class="hljs-keyword">db</span> <br>aed84ee2lbde training/webapp:latest python <span class="hljs-keyword">app</span>.py 16 hours ago Up 2 minutes <br>0.0.0.0:49154-&gt;5000/tcp web<br></code></pre></td></tr></table></figure>

<p>Docker通过两种方式为容器公开连接信息：</p>
<p>​        更新环境变量；</p>
<p>​        更新 /etc/hosts 文件。</p>
<p>使用 env 命令来查看 web 容器的环境变量：</p>
<p>$ docker run –rm –name web2 –link db:db training/webapp env </p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Docker/">Docker</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/09/Mac%E4%B8%ADdocker%E5%AE%89%E8%A3%85Redis%E6%AD%A5%E9%AA%A4/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Mac中docker安装Redis步骤</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/25/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">
                        <span class="hidden-mobile">nginx反向代理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/Latiy-125/Latiy-125.github.io" target="_blank" rel="nofollow noopener"><span>Latiy</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
